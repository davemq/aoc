* 1a
** Description excerpts

Due to new security protocols, the password is locked in the safe
below. Please see the attached document for the new combination."

The safe has a dial with only an arrow on it; around the dial are the
numbers 0 through 99 in order. As you turn the dial, it makes a small
click noise as it reaches each number.

The attached document (your puzzle input) contains a sequence of
rotations, one per line, which tell you how to open the safe. A
rotation starts with an L or R which indicates whether the rotation
should be to the left (toward lower numbers) or to the right (toward
higher numbers). Then, the rotation has a distance value which
indicates how many clicks the dial should be rotated in that
direction.

So, if the dial were pointing at 11, a rotation of R8 would cause the
dial to point at 19. After that, a rotation of L19 would cause it to
point at 0.

Because the dial is a circle, turning the dial left from 0 one click
makes it point at 99. Similarly, turning the dial right from 99 one
click makes it point at 0.

So, if the dial were pointing at 5, a rotation of L10 would cause it
to point at 95. After that, a rotation of R5 could cause it to point
at 0.

The dial starts by pointing at 50.

You could follow the instructions, but your recent required official
North Pole secret entrance security training seminar taught you that
the safe is actually a decoy. The actual password is the number of
times the dial is left pointing at 0 after any rotation in the
sequence.

** Imports

sys is needed for sys.exit().

#+begin_src python :tangle 1.py :comments both
import sys
#+end_src

** Dial class

In Python, create a src_python{Dial(int)} type. Overload addition and
subtraction operators to apply src_python(%= 100} to the results.

#+begin_src python :tangle 1.py :comments both
class Dial(int):
    """Dial class from 0-99. Uses modular arithmetic."""

    value: int = 50

    def __add__(self, other):
        return (self.value + int(other)) % 100

    def __sub__(self, other):
        return (self.value - int(other)) % 100

    def __iadd__(self, other):
        self.value += int(other)
        self.value %= 100
        return self

    def __isub__(self, other):
        self.value -= int(other)
        self.value %= 100
        return self

    def __int__(self):
        return self.value

    def __repr__(self):
        return f"Dial({self.value})"
#+end_src

** Create a Dial.

#+begin_src python :tangle 1.py :comments both
d = Dial()
#+end_src

** Create a counter

#+begin_src python :tangle 1.py :comments both
counter = 0
#+end_src

** Open input file

#+begin_src python :tangle 1.py :comments both
with open("input.txt", "r") as input:
#+end_src

** Read lines

#+begin_src python :tangle 1.py :comments both
    for line in input:
#+end_src

The lines are in the form [LR]number.

** Get number

Characters from 1 to the end of the string are the number.

#+begin_src python :tangle 1.py :comments both
        number = int(line[1:])
#+end_src

** Add or subtract number

#+begin_src python :tangle 1.py :comments both
        first = line[0]
        if first == 'L':
            d -= number
        elif first == 'R':
            d += number
        else:
            print(f"unknown direction '{first}'")
            sys.exit(1)
#+end_src

** Check if dial is 0

If the dial is at 0, increment the counter.

#+begin_src python :tangle 1.py :comments both
        if int(d) == 0:
            counter += 1
#+end_src

** Print counter

Once we've finished the input, print the counter.

#+begin_src python :tangle 1.py :comments both
print(counter)
#+end_src
