* 1a
** Description excerpts

Due to new security protocols, the password is locked in the safe
below. Please see the attached document for the new combination."

The safe has a dial with only an arrow on it; around the dial are the
numbers 0 through 99 in order. As you turn the dial, it makes a small
click noise as it reaches each number.

The attached document (your puzzle input) contains a sequence of
rotations, one per line, which tell you how to open the safe. A
rotation starts with an L or R which indicates whether the rotation
should be to the left (toward lower numbers) or to the right (toward
higher numbers). Then, the rotation has a distance value which
indicates how many clicks the dial should be rotated in that
direction.

So, if the dial were pointing at 11, a rotation of R8 would cause the
dial to point at 19. After that, a rotation of L19 would cause it to
point at 0.

Because the dial is a circle, turning the dial left from 0 one click
makes it point at 99. Similarly, turning the dial right from 99 one
click makes it point at 0.

So, if the dial were pointing at 5, a rotation of L10 would cause it
to point at 95. After that, a rotation of R5 could cause it to point
at 0.

The dial starts by pointing at 50.

You could follow the instructions, but your recent required official
North Pole secret entrance security training seminar taught you that
the safe is actually a decoy. The actual password is the number of
times the dial is left pointing at 0 after any rotation in the
sequence.

** Imports

sys is needed for sys.exit().

#+begin_src python :tangle 1a.py :comments both
import sys
#+end_src

** Dial class

In Python, create a src_python{Dial(int)} type. Overload addition and
subtraction operators to apply src_python(%= 100} to the results.

#+begin_src python :tangle 1a.py :comments both
class Dial(tuple):
    """
    Dial class from 0-99.

    - Uses modular arithmetic.
    - Counts rotations that pass 0.
    """

    value: int = 50
    count: int = 0

    def __init__(self):
        self = (self.value, self.count)

    def __add__(self, other):
        d = self

        if isinstance(other, Dial):
            d.count += other.count
            d.value += other.value
        else:
            d.value += int(other)
        d = (d.value, d.count)
        return d

    def __sub__(self, other):
        d = self

        if isinstance(other, Dial):
            d.count -= other.count
            d.value -= other.value
        else:
            d.value -= int(other)
        d = (d.value, d.count)
        return d

    def __iadd__(self, other):
        if isinstance(other, Dial):
            self.count += other.count
            self.value += other.value
        else:
            self.value += int(other)
        self = (self.value, self.count)
        return self

    def __isub__(self, other):
        if isinstance(other, Dial):
            self.count -= other.count
            self.value -= other.value
        else:
            self.value -= int(other)
        self = (self.value, self.count)
        return self

    def __int__(self):
        return self.value

    def __repr__(self):
        return f"Dial({self.value},{self.count})"
#+end_src

** Create a Dial.

#+begin_src python :tangle 1a.py :comments both
d = Dial()
#+end_src

** Create a counter

#+begin_src python :tangle 1a.py :comments both
counter = 0
#+end_src

** Open input file

#+begin_src python :tangle 1a.py :comments both
with open("input.txt", "r") as input:
#+end_src

** Read lines

#+begin_src python :tangle 1a.py :comments both
    for line in input:
#+end_src

The lines are in the form [LR]number.

** Get number

Characters from 1 to the end of the string are the number.

#+begin_src python :tangle 1a.py :comments both
        number = int(line[1:])
#+end_src

** Add or subtract number

#+begin_src python :tangle 1a.py :comments both
        first = line[0]
        if first == 'L':
            d -= number
        elif first == 'R':
            d += number
        else:
            print(f"unknown direction '{first}'")
            sys.exit(1)
#+end_src

** Check if dial is 0

If the dial is at 0, increment the counter.

#+begin_src python :tangle 1a.py :comments both
        if int(d) == 0:
            counter += 1
#+end_src

** Print counter

Once we've finished the input, print the counter.

#+begin_src python :tangle 1a.py :comments both
print(counter)
#+end_src


* 1b

Like 1a, but now we count passing 0 during a rotation.

Overload the tuple type in he Dial class to also count passes. The
algorithm for counting passes can be added to the
__add__/__iadd__/__sub__/__isub__ methods.

In the additive case, just divide the result by 100.

For the subtractive case, its a little more complicated.
- If result < 0, that's 1 time
- Then add abs(result) / 100

I will also likely put this in just the add/sub versions, and call
these from iadd/isub.

** Imports

sys is needed for sys.exit().

#+begin_src python :tangle 1b.py :comments both
import sys
#+end_src

** Dial class
In Python, create a src_python{Dial(tuple)} type, with the tuple being
(dial, count). Overload addition and subtraction operators to apply
src_python(%= 100} to the results. Count rotations passing in count.

#+begin_src python :tangle 1b.py :comments both
class Dial(tuple):
    """
    Dial class from 0-99.

    - Uses modular arithmetic.
    - Counts rotations that pass 0.
    """

    value: int = 50
    count: int = 0

    def __new__(cls, *args, **kwargs):
        instance = super().__new__(cls)
        return instance

    def __init__(self):
        self = (self.value, self.count)

    def __add__(self, other):
        _new0 = tuple(self)

        if isinstance(other, Dial):
            _new0.count += other.count
            _new0.value += other.value
        else:
            _new0.value += int(other)
        _new0.count += _new0.value // 100
        _new0.value %= 100
        _new0 = (_new0.value, _new0.count)
        return _new0

    def __sub__(self, other):
        _new1 = tuple(self)

        if isinstance(other, Dial):
            _new1.count -= other.count
            _new1.value -= other.value
        else:
            _new1.value -= int(other)
        if _new1.value <= 0:
            _new1.count += 1
            _new1.count += abs(_new1.value) // 100
        _new1.value %= 100
        _new1 = (_new1.value, _new1.count)
        return _new1

    def __iadd__(self, other):
        if isinstance(other, Dial):
            self.count += other.count
            self.value += other.value
        else:
            self.value += int(other)
        self.count += self.value // 100
        self.value %= 100
        self = (self.value, self.count)
        return self

    def __isub__(self, other):
        if isinstance(other, Dial):
            self.count -= other.count
            self.value -= other.value
        else:
            self.value -= int(other)
        if self.value <= 0:
            self.count += 1
            self.count += abs(self.value) // 100
        self.value %= 100
        self = (self.value, self.count)
        return self

    def __int__(self):
        return self.value

    def __repr__(self):
        return f"Dial({self.value},{self.count})"
#+end_src
