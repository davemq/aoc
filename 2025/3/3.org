* 3

** 3a

#+begin_quote
There are batteries nearby that can supply emergency power to the
escalator for just such an occasion. The batteries are each labeled
with their joltage rating, a value from 1 to 9. You make a note of
their joltage ratings (your puzzle input). For example:

987654321111111
811111111111119
234234234234278
818181911112111

The batteries are arranged into banks; each line of digits in your
input corresponds to a single bank of batteries. Within each bank, you
need to turn on exactly two batteries; the joltage that the bank
produces is equal to the number formed by the digits on the batteries
you've turned on. For example, if you have a bank like 12345 and you
turn on batteries 2 and 4, the bank would produce 24 jolts. (You
cannot rearrange batteries.)

You'll need to find the largest possible joltage each bank can
produce. In the above example:

In 987654321111111, you can make the largest joltage possible, 98, by
turning on the first two batteries.
In 811111111111119, you can make the largest joltage possible by
turning on the batteries labeled 8 and 9, producing 89 jolts.
In 234234234234278, you can make 78 by turning on the last two
batteries (marked 7 and 8).
In 818181911112111, the largest joltage you can produce is 92.
The total output joltage is the sum of the maximum joltage from each
bank, so in this example, the total output joltage is 98 + 89 + 78 +
92 = 357.

There are many batteries in front of you. Find the maximum joltage
possible from each bank; what is the total output joltage?
#+end_quote

*** Idea

A naive way to do this would be to search each line for "9.*9", then
"9.*8", then "9.*7", etc. This seems slow!

My approach would be to search for "9[0-9]", then "8[0-9]", then
"7[0-9]". This gives us the digit with the highest value, but avoids
the last character on the line.

Then search from just after the highest digit for "9", then "8", then
"7", etc.

This /should/ give the largest value, i.e. the /joltage/, for a line.

*** Code

Open the file and read line by line. Or read the data and split by
lines. We can process each line as we read it, or read them all into a
list and then process each item in the list. But either way, I think
the search is complex enough for its own function.

**** Imports

#+begin_src python :tangle 3a.py :comments both
import re
import sys
#+end_src

**** Search function

#+begin_src python :tangle 3a.py :comments both
def joltage(line):
    """
    Search line for the joltage, which is the highest value digit followed by
    the highest value digit after this first digit. Return the joltage.
    """

    # Search for first digit. If we find nothing, "decrement" the first
    # character. Continue searching until we find something. If for some reason
    # we don't find anything, yell about it, as it shouldn't happen.
    result = None
    for digit in range(9, -1, -1):
        pat1 = str(digit) + "[0-9]"
        result = re.search(pat1, line)
        if result:
            break
    if not result:
        # this shouldn't happen!
        sys.exit(f'No digits in "{line}"')
    first = digit

    # Now search for second digit, starting just after result from the search
    # above. Similar to above, start with "9" and "decrement" down to 0. And
    # again, if we don't find something, complain.
    result2 = None
    for digit in range(9, -1, -1):
        result2 = re.search(str(digit), line[result.start() + 1:])
        if result2:
            break
    if not result2:
        # This sholdn't happen!
        sys.exit(f'No second digit in "{line}"')
    second = digit

    return first * 10 + second
#+end_src

**** Create joltage sum

#+begin_src python :tangle 3a.py :comments both
joltage_sum = 0
#+end_src

**** Process input file

- Open file
- Read each line
  - compute joltage
  - add to joltage sum

#+begin_src python :tangle 3a.py :comments both
with open("input.txt", "r") as f:
    for line in f:
        joltage_sum += joltage(line)
#+end_src

**** Print joltage sum

#+begin_src python :tangle 3a.py :comments both
print(joltage_sum)
#+end_src

** 3b

#+begin_quote
Now, you need to make the largest joltage by turning on exactly twelve batteries within each bank.

The joltage output for the bank is still the number formed by the digits of the batteries you've turned on; the only difference is that now there will be 12 digits in each bank's joltage output instead of two.

Consider again the example from before:

987654321111111
811111111111119
234234234234278
818181911112111
Now, the joltages are much larger:

In 987654321111111, the largest joltage can be found by turning on everything except some 1s at the end to produce 987654321111.
In the digit sequence 811111111111119, the largest joltage can be found by turning on everything except some 1s, producing 811111111119.
In 234234234234278, the largest joltage can be found by turning on everything except a 2 battery, a 3 battery, and another 2 battery near the start to produce 434234234278.
In 818181911112111, the joltage 888911112111 is produced by turning on everything except some 1s near the front.
The total output joltage is now much larger: 987654321111 + 811111111119 + 434234234278 + 888911112111 = 3121910778619.

What is the new total output joltage?
#+end_quote

*** Idea

Again, you could take a naive approach and try to search for all 9s,
then 11 9s followed by and 8, etc. If this was a naive approach for
part 1, it's /really/ naive for part 2. I imagine starting it and
walking away for quite some time!

Similar to part 1, but in this case you need to leave room for the
additional digits for each search. So for each line you need to search
for all 12 digits. The first digit search starts with
"9\\d{11}".[fn:1] Of course, if the program doesn't find this pattern,
then "8\\d{11}", "7\\d{11}", etc.

Then for the next digit, start the search with "9\\d{10}".

Another issue is tracking where we are in the string. I wonder if
recursion might make this easier, rather than adding up all the
offsets. Start with searching for 12 digits, then call again from
within 12 to search for 11, etc. After you search for 1 digit, you
should be able to just return it. For the 2 digit search, do your
search for the first of 2, then call for the 1 digit search, then do a
string add on the results "first + second".

I'm going to start with this approach and see how it goes.

**** Searhc optimization

In working on the search function, I came across situations where the
search is looking for N digits when there are exactly N digits in
the string. It would be a nice optimization to detect this and just
return the whole string, cutting off the recursion and search perhaps
considerably.

*** Code

**** Imports

#+begin_src python :tangle 3b.py :comments both
import re
import sys
#+end_src

**** Search function

#+begin_src python :tangle 3b.py :comments both
def search(s, digits):
    """
    Search str for digits \\d instances. Try to find the largest value by
    starting the search with 9, then 8, etc.

    An optimization occurs first. If we have exactly digits characters in s,
    return s, as we assume all the characters are digits.

    Once we find our first digit, recurse to find digits-1 digits. When that
    value is returned, add it to our digit, then return.
    """

    if len(s) == digits:
        return s

    # I was a bit concerned by \\d{0} was invalid, but it seems okay
    for d in range(9, -1, -1):
        pat = str(d) + "\\d{" + str(digits - 1) + "}"

        m = re.search(pat, s)
        if m:
            digit = str(d)
            break

    if not m:
        sys.exit(f'can\'t find "{pat}" in "{s}"')

    if digits <= 1:
        return digit

    # Get the rest of the digits
    rest = search(s[m.start()+1:], digits-1)

    return digit + rest
#+end_src

**** Set up sum

#+begin_src python :tangle 3b.py :comments both
joltage_sum = 0
#+end_src

**** Main loop

Open the file and do the search line by line. Add the result to the
sum.

#+begin_src python :tangle 3b.py :comments both
with open("input.txt", "r") as f:
    for line in f:
        joltage_sum += int(search(line, 12))
#+end_src

**** Print sum

#+begin_src python :tangle 3b.py :comments both
print(joltage_sum)
#+end_src

* Footnotes

[fn:1] I'm using \d here instead of [0-9] as it should also work.
There's a chance of picking up extra characters as digits with \d, but
having seen the input file, this is not a concern.
