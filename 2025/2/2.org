* 2a

As it turns out, one of the younger Elves was playing on a gift shop
computer and managed to add a whole bunch of invalid product IDs to
their gift shop database! Surely, it would be no trouble for you to
identify the invalid product IDs for them, right?

They've even checked most of the product ID ranges already; they only
have a few product ID ranges (your puzzle input) that you'll need to
check. For example:

11-22,95-115,998-1012,1188511880-1188511890,222220-222224,
1698522-1698528,446443-446449,38593856-38593862,565653-565659,
824824821-824824827,2121212118-2121212124
(The ID ranges are wrapped here for legibility; in your input, they
appear on a single long line.)

The ranges are separated by commas (,); each range gives its first ID
and last ID separated by a dash (-).

Since the young Elf was just doing silly patterns, you can find the
invalid IDs by looking for any ID which is made only of some sequence
of digits repeated twice. So, 55 (5 twice), 6464 (64 twice), and
123123 (123 twice) would all be invalid IDs.

None of the numbers have leading zeroes; 0101 isn't an ID at all. (101
is a valid ID that you would ignore.)

Your job is to find all of the invalid IDs that appear in the given
ranges. In the above example:

11-22 has two invalid IDs, 11 and 22.
95-115 has one invalid ID, 99.
998-1012 has one invalid ID, 1010.
1188511880-1188511890 has one invalid ID, 1188511885.
222220-222224 has one invalid ID, 222222.
1698522-1698528 contains no invalid IDs.
446443-446449 has one invalid ID, 446446.
38593856-38593862 has one invalid ID, 38593859.
The rest of the ranges contain no invalid IDs.
Adding up all the invalid IDs in this example produces 1227775554.

What do you get if you add up all of the invalid IDs?

** Notes

*** Invalid IDs

Invalid IDs always have an even number of digits. If a range only has
an odd number of digits, it has no invalid IDs.

Invalid IDs start with [1-9]. Additional digits are in the [0-9]
regular expression class.

I'm thinking about using regular expressions to search for invalid
IDs. A regular expression generator would be useful here.

E.g. the first range in the list is 4077-5314. All of the IDs are 4
digits long, so we should check this range. The repeating expression
will be 2 digits long. We should check from 4040 to 5252. 4040 is out
of range. We could check whether int(min[0:1]) < (min[2:3]) and
skip over it as out of range. In this case start with
(int(min[0:1]) + 1) * 101. If int(min[0:1]) >= (min[2:3]) then
we can start with int(min[0:1]) * 101.

*** Ranges

The ranges are on a single line separated by commas (,). So read the
line and split with ',' as the separator to get a list of ranges.

The ranges are in the form minimum-maximum. So again, split the range
string with '-' to get the min and max.

** Code

Read the input file and parsing the ranges.

#+begin_src python :tangle 2a.py :comments both
ranges = []
with open("input.txt", "r") as file:
    for line in file:
        line = line.rstrip('\n')
        ranges += [r.split('-') for r in line.split(',')]
#+end_src

Set up a sum of invalid IDs.

#+begin_src python :tangle 2a.py :comments both
invalids_sum = 0
#+end_src

Walk through the ranges.
- Grab first "half" of the minimum string. If the minimum string
  length is odd, this may produce an initial candidate string that's
  quite low
- If the first half of the minimum string is 0 length, then set the
  string to "1". This covers a range that starts between 1 and 9 and
  may or may not end in a two digit number

#+begin_src python :tangle 2a.py :comments both
for r in ranges:
    length = len(r[0]) >> 1
    start = r[0][0:length]
    if len(start) == 0:
        start = "1"
    loopstart = int(r[0])
    loopend = int(r[1])
    candidate = int(start + start)
    while candidate < loopstart:
        start = str(int(start) + 1)
        candidate = int(start + start)
    while candidate in range(loopstart, loopend + 1):
        invalids_sum += candidate
        start = str(int(start) + 1)
        candidate = int(start + start)
#+end_src

Print sum of invalids

#+begin_src python :tangle 2a.py :comments both
print(invalids_sum)
#+end_src

* 2b

#+begin_quote
The clerk quickly discovers that there are still invalid IDs in the
ranges in your list. Maybe the young Elf was doing other silly
patterns as well?

Now, an ID is invalid if it is made only of some sequence of digits
repeated at least twice. So, 12341234 (1234 two times), 123123123 (123
three times), 1212121212 (12 five times), and 1111111 (1 seven times)
are all invalid IDs.
#+end_quote

#+begin_quote
What do you get if you add up all of the invalid IDs using these new
rules?
#+end_quote

I can reuse much of the code from 2a, but now instead of only dealing
with the first half of the minimum range for the start, start with the
first character of the mininum. Construct the starting string by
multiplying the first character times the len of the minimum string.
Use a set to figure out which IDs are invalid. That way duplicates
only count once.

After going through the single character strings, grab the first 2
characters of the minimum string, and multiply times the half length
of the minimum string. Repeat the process.

Stop grabbing the N character prefix when N > len(minimum string) / 2.

It would probably be best for debugability to add the invalid IDs from
the set as you go along, and start with a clean set when we start
looking at a new range.

** Issues

I'm having issues with ranges that cross from N digits to N+1
digits. I think I may be able to make things work better if I split
these ranges into things like XXXX-9999 and 10000-YYYYY. The code is
muddled trying to handle N or N+1 digits in naive ways. Splitting the
range into two ranges should make things easier.

There may also still be the corner case of 2-9, but I can add some
special code for that.

The input has a range of 2-16, so it can be split into 2-9, with no
invalid IDs, and 10-16, which has 11 as an invalid ID.

** Code

Add a function to split a range where the minimum and maximum values
have a different number of digits, e.g. 85-102, into two ranges, each
with minimum and maximum having the same number of digits

#+begin_src python :tangle 2b.py :comments both
def split_range(r):
    minlen = len(r[0])
    maxlen = len(r[1])
    if minlen == maxlen:
        return r

    # create lower range from r[0] and "9" * minlen
    lowrange = [r[0], "9" * minlen]

    # create upper range from "1" * "0" * maxlen-1 and r[1]
    upperrange = ["1" + "0" * (maxlen-1), r[1]]

    return [lowrange, upperrange]
#+end_src

Read the input file and parsing the ranges.

#+begin_src python :tangle 2b.py :comments both
ranges = []
with open("input.txt", "r") as file:
    for line in file:
        line = line.rstrip('\n')
        ranges += [r.split('-') for r in line.split(',')]
print(f"{ranges=}")
#+end_src

Split ranges that cross length boundaries

#+begin_src python :tangle 2b.py :comments both
newr = []
for r in ranges:
    s = split_range(r)
    if s == r:
        newr.append(r)
    else:
        for i in s:
            newr.append(i)
ranges = newr
print(f"{ranges=}")
#+end_src

Set up a sum of invalid IDs.

#+begin_src python :tangle 2b.py :comments both
invalids_sum = 0
#+end_src

Main loop

#+begin_src python :tangle 2b.py :comments both
for r in ranges:
    print(f"{r[0]}-{r[1]}")
    invalids = set()
    maxlength = len(r[0]) >> 1
    if maxlength < 1:
        continue
    print(f"{maxlength=}")
    length = 1
    while length <= maxlength:
        start = r[0][0:length]
        loopstart = int(r[0])
        loopend = int(r[1])
        candidate = int(start * (len(r[0]) // length))
        while candidate < loopstart:
            start = str(int(start) + 1)
            candidate = int(start * (len(r[0]) // length))
        while candidate in range(loopstart, loopend + 1):
            invalids.add(candidate)
            start = str(int(start) + 1)
            candidate = int(start * (len(r[0]) // length))
        length += 1
    print(f"{invalids=}")
    invalids_sum += sum(invalids)
#+end_src

Print sum of invalids

#+begin_src python :tangle 2b.py :comments both
print(invalids_sum)
#+end_src
